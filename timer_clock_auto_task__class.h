#pragma once
#include <iostream>
#include <string>
#include <chrono> 
#include <functional>

#include "timer_auto_task__class.h"


#pragma warning(disable : 4996) //[для MSVC] _CRT_SECURE_NO_WARNINGS       - для localtime()







class timer_clock_auto_task__class
{

public:

	struct date_time__struct
	{
		int year;
		int month;
		int day;
		int hour;
		int min;
		int sec;
	};

public:




	void set_number_threads(const int numm_threads)
	{
		timer_auto_task__class_.set_number_threads(numm_threads);      //Устанвливаем кол-во потоков которое будет обробатывать очередь std::function
	}

	int add_timer_string(std::string& data, const std::function<void()> f_object)
	{



		//-----------------------------------------------------------------------Получим текущую дату и время:Начало-----------------------------------------------------------------------------

		//Получим текущую дату:


		std::chrono::time_point<std::chrono::system_clock>system_clock_Current = std::chrono::system_clock::now();                        //Получаем текущее время

		std::time_t time_current = std::chrono::system_clock::to_time_t(system_clock_Current);                                            //Преобразовыаем текущее время в time_t - это время в секундах ОТ какого то момента в прошлом, на большинстве систем от 1970 года, то текущего момента.

		//-----------------------------------------------------------------------Получим текущую дату и время:Конец-----------------------------------------------------------------------------



		std::chrono::time_point<std::chrono::system_clock> system_clock_Current11 = std::chrono::system_clock::now();
		std::time_t time11 = std::chrono::system_clock::to_time_t(system_clock_Current11);
		std::tm* tm = std::localtime(&time11);


		//----------------------------------------------------------Преобразуем дату и время переданную Пользователем в std::time_t:Начало------------------------------------------------------------------------

	    //Если Пользователь передал дату и время в виде текстовой сроки:


		int status = get_data_from_string(data);

		if (status == -1)
		{
			error_ = "timer_clock_auto_task__class: add_timer: " + error_;
			return -1;
		}
		else
		{
			//Значит тут теперь "tm_" - дата и время, которое указал Пользовтаель готовое для перевода в time_t.
		}


		std::time_t time_user = std::mktime(&tm_);

		if (time_user == -1)
		{
			error_ = "timer_clock_auto_task__class: add_timer_string: std::mktime return -1";
			return -1;
		}
		else
		{
			//Значит теперь тут "time_user" - время Пользователя в которое должен сработать таймер преобразованный в "time_t"
		}

		//----------------------------------------------------------Преобразуем дату и время переданную Пользователем в std::time_t:Конец------------------------------------------------------------------------







		//----------------------------------------Расчитаем разницу между текущем временем и тем, который указал Пользовтаель в качестве сигнала таймера:Начало--------------------------------------------------

		std::time_t timet_diff = time_user - time_current;  //То есть это время в секунах, которая соответвует указанной дате и времени Пользователем, которое должно пройти с этого текущего момента времени, до того, как должен сработать таймер - то есть до указанного ПОльзователем даты и времени.

		//----------------------------------------Расчитаем разницу между текущем временем и тем, который указал Пользовтаель в качестве сигнала таймера:Коненц--------------------------------------------------






		//-------------------------------------------------------------------------------Добавляем таймер:Начало-------------------------------------------------------------------------------------------------

		//Теперь все что осталось сделать - это воспользоватся уже готовым классом "timer_auto_task__class", который добавляет таймеры на срабатывание.

		timer_auto_task__class_.add_timer(timet_diff, f_object);

		//-------------------------------------------------------------------------------Добавляем таймер:Конец-------------------------------------------------------------------------------------------------



		return 0;
	}

	int add_timer_struct(date_time__struct& date_time__struct_ref, std::function<void()> f_object)
	{



		//-----------------------------------------------------------------------Получим текущую дату и время:Начало-----------------------------------------------------------------------------

		//Получим текущую дату:


		std::chrono::time_point<std::chrono::system_clock>system_clock_Current = std::chrono::system_clock::now();                //Получаем текущее время

		std::time_t time_current = std::chrono::system_clock::to_time_t(system_clock_Current);                                            //Преобразовыаем текущее время в time_t - это время в секундах ОТ какого то момента в прошлом, на большинстве систем от 1970 года, то текущего момента.

		//-----------------------------------------------------------------------Получим текущую дату и время:Конец-----------------------------------------------------------------------------







		//----------------------------------------------------------Преобразуем дату и время переданную Пользователем в std::time_t:Начало------------------------------------------------------------------------

			//Если Пользователь предал дату и время в виде структуры значений: значит тут "date_time__struct_ref" - дата и время, которое указал пользователь. Эти данные нужно привести к данным структуры std::tm.


		get_cast_time_struct(date_time__struct_ref);

		//Значит тут теперь "tm_" - дата и время, которое указал Пользовтаель готовое для перевода в time_t.




		std::time_t time_user = std::mktime(&tm_);

		if (time_user == -1)
		{
			error_ = "timer_clock_auto_task__class: add_timer: std::mktime return -1";
			return -1;
		}
		else
		{
			//Знчит теперь тут "time_user" - время Пользователя в которое должен сработать таймер преобразованный в "time_t"
		}

		//----------------------------------------------------------Преобразуем дату и время переданную Пользователем в std::time_t:Конец------------------------------------------------------------------------







		//----------------------------------------Расчитаем разницу между текущем временем и тем, который указал Пользовтаель в качестве сигнала таймера:Начало--------------------------------------------------

		std::time_t timet_diff = time_user - time_current;  //То есть это время в секунах, которая соответвует указанной дате и времени Пользователем, которое должно пройти с этого текущего момента времени, до того, как должен сработать таймер - то есть до указанного ПОльзователем даты и времени.

		//----------------------------------------Расчитаем разницу между текущем временем и тем, который указал Пользовтаель в качестве сигнала таймера:Коненц--------------------------------------------------






		//-------------------------------------------------------------------------------Добавляем таймер:Начало-------------------------------------------------------------------------------------------------

		//Теперь все что осталось сделать - это воспользоватся уже готовым классом "timer_auto_task__class", который добавляет таймеры на срабатывание.

		timer_auto_task__class_.add_timer(timet_diff, std::move(f_object));

		//-------------------------------------------------------------------------------Добавляем таймер:Конец-------------------------------------------------------------------------------------------------



		return 0;
	}

	~timer_clock_auto_task__class()
	{
		//...
	}



	std::string& get_last_error()
	{
		return error_;
	}


private:


	std::string error_;

	//------------------------------------------
	date_time__struct date_time__struct_;
	std::tm tm_ = {};
	timer_auto_task__class<std::chrono::seconds>timer_auto_task__class_;
	//------------------------------------------



	//---------------------------------------------------------------------Str_func__get_split_ranges__substr_in_str__strstr__Ex:Начало--------------------------------------------------------------------------------

	struct Str_func__get_split_ranges__substr_in_str__strstr__struct
	{
		char* char_beg_p;
		size_t length_byte;
	};



	int Str_func__get_split_ranges__substr_in_str__strstr(char* const beg_pointer_string, const char* const end_pointer_string, const char* const beg_pointer_substring, const size_t substring_size, std::vector<Str_func__get_split_ranges__substr_in_str__strstr__struct>& vector_point_ranges_split)
	{


		//-------------------Предварительные настройки:----------------------
		size_t cntr = 0;   //Установим счетчик перед началом.
		//-------------------------------------------------------------------



		//------------------------------------------
		vector_point_ranges_split.resize(0);
		char* sequence_point;
		//------------------------------------------



		char* position_1 = beg_pointer_string;




		//****************************************************************Part_1:Начало***********************************************************************

		sequence_point = strstr(position_1, beg_pointer_substring);   //Если strstr находит подстроку то возвращает указатель на начало этой подстроки в искомом массиве, если не находит возвращает нулевой указатель.




		if (sequence_point == 0)
		{
			//Значит strstr не нашла подстроку:


			if (cntr == 0)    //Если my_pointer_func_find в первый раз вернула ноль, то значит подстроки нет в указанном диапазоне
			{
				return 4;    //Не найдено
			}

		}
		else
		{
			//Если strstr нашла подстроку:


			cntr = 1;  //Установим счетчик в один, что говорит, что минимум один вызов функции my_pointer_func_find уже был.


			//----------------------------добавим диапазоны указателей:Начало----------------------------------

			if (sequence_point != beg_pointer_string)
			{
				//Значит найденная подстрока не равна символу с которого мы начали поиск подстроки:    значит занесем диапазоны в вектор

				vector_point_ranges_split.emplace_back(Str_func__get_split_ranges__substr_in_str__strstr__struct{ beg_pointer_string, (size_t)(sequence_point - beg_pointer_string) });
			}
			else
			{
				//Значит найденная подстрока равна символу с которого мы начали поиск подсроки: то есть анйденная подстрока была с самого символа с которго мы вызвали strstr.
				//В данном случае никакого диапазона перед найденой подстрокой нет, ничего не далеаем.
			}



			//-------------------------------------------------
			position_1 = sequence_point + substring_size;            //Устанавливаем указатель на байт следующий сразу за найденной подстркоой.

			if ((position_1 + substring_size) - 1 > end_pointer_string)
			{
				//Значит кол-во байт начианая с байта сразу после найденой подстроки ДО позиции end_pointer_string вклячая до которого мы должны искать - меньше, чем размер подстроки, котоырй мы должны найти - ЗНАЧИТ нет смысла дальше продолжать поиск, так как подстроки мы там уже не найдем.


				if (position_1 > end_pointer_string)
				{
					//Значит найденная подстрока - это первая подстрока во всей строке в которой мы ищем и значит после этой найденой подстроки больше нет вообще символов, которые можно было бы поместить в вектор "vector_point_ranges_split".
					return 0;
				}
				else
				{
					vector_point_ranges_split.emplace_back(Str_func__get_split_ranges__substr_in_str__strstr__struct{ position_1,  (size_t)(end_pointer_string - position_1 + 1) });

					return 0;
				}
			}
			//-------------------------------------------------

			//----------------------------добавим диапазоны указателей:Конец----------------------------------

		}



		//****************************************************************Part_1:Конец***********************************************************************









		//****************************************************************Part_2:Начало***********************************************************************

	repeat:


		sequence_point = strstr(position_1, beg_pointer_substring);   //Если strstr находит подстроку то возвращает указатель на начало этой подстроки в искомом массиве, если не находит возвращает нулевой указатель.




		if (sequence_point == 0)
		{
			//Значит strstr не нашла подстроку:


			if (cntr == 0)    //Если my_pointer_func_find в первый раз вернула ноль, то значит подстроки нет в указанном диапазоне
			{
				return 4;    //Не найдено
			}
			else             //Если strstr вернула ноль, но это уже был минимум второй запуск, то все подстроки найдены и обсчитаны, то завершаем успешно
			{

				vector_point_ranges_split.emplace_back(Str_func__get_split_ranges__substr_in_str__strstr__struct{ position_1, (size_t)(end_pointer_string - position_1 + 1) });

				return 0;    //Найдено и подсчитано
			}

		}
		else
		{
			//Если strstr нашла подстроку:


			//cntr = 1;  //Установим счетчик в один, что говорит, что минимум один вызов функции my_pointer_func_find уже был.


			//----------------------------добавим диапазоны указателей:Начало----------------------------------

			if (sequence_point != position_1)
			{
				//Значит найденная подстрока не равна символу с которого мы начали поиск подстроки:    значит занесем диапазоны в вектор

				vector_point_ranges_split.emplace_back(Str_func__get_split_ranges__substr_in_str__strstr__struct{ position_1, (size_t)(sequence_point - position_1) });
			}
			else
			{
				//Значит найденная подстрока равна символу с которого мы начали поиск подсроки: то есть анйденная подстрока была с самого символа с которго мы вызвали strstr.
				//В данном случае никакого диапазона перед найденой подстрокой нет, ничего не далеаем.
			}



			//-------------------------------------------------
			position_1 = sequence_point + substring_size;            //Устанавливаем указатель на байт следующий сразу за найденной подстрокой.

			if ((position_1 + substring_size) - 1 > end_pointer_string)
			{
				//Значит кол-во байт начианая с байта сразу после найденой подстроки ДО позиции position_2 вклячая до которого мы должны искать - меньше, чем размер подстроки, котоырй мы должны найти - ЗНАЧИТ нет смысла дальше продолжать поиск, так как подстроки мы там уже не найдем.


				if (position_1 > end_pointer_string)
				{
					//Значит найденная подстрока - это последняя подстрока во всей строке в которой мы ищем и значит после этой найденой подстроки больше нет вообще символов, которые можно было бы поместить в вектор "vector_point_ranges_split".
					return 0;
				}
				else
				{
					vector_point_ranges_split.emplace_back(Str_func__get_split_ranges__substr_in_str__strstr__struct{ position_1,  (size_t)(end_pointer_string - position_1 + 1) });

					return 0;
				}
			}
			//-------------------------------------------------

			goto repeat;

			//----------------------------добавим диапазоны указателей:Конец----------------------------------

		}

		//****************************************************************Part_2:Начало***********************************************************************


		return -1; //Что то пошло не так...
	}


	std::vector<Str_func__get_split_ranges__substr_in_str__strstr__struct>vector_ranges_split;
	//---------------------------------------------------------------------Str_func__get_split_ranges__substr_in_str__strstr__Ex:Конец--------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------adapter_class:Начало----------------------------------------------------------------------------------------------------
	class adapter_class
	{


	public:

		inline char* get_Cstring(char* char_beg_p, size_t length_byte)
		{
			char_p__temp = char_beg_p + length_byte;    //Берем указатель на байт начала найденной подстроки или точнее сразу за "подстрокой" которая находится между найденными посдтроками.

			char_temp = *char_p__temp;                  //Берем значание это символа во временный char, чтобы потом возвратить его обратно.

			*char_p__temp = 0;                          //Зналуяем его, чтобы у нас получилась обычная Сишная строка начиная с "char_beg_p"

			return char_beg_p;
		}

		inline void bring_back()
		{
			*char_p__temp = char_temp;                 //Возвращаем обратно.
		}


	private:

		char char_temp;
		char* char_p__temp;

	};

	adapter_class adapter_class_;
	//-----------------------------------------------------------------------------------------adapter_class:Конец----------------------------------------------------------------------------------------------------







	//-----------------------------------------------------------------------------------get_data_from_string:Начало---------------------------------------------------------------------------------------------------

	int get_data_from_string(std::string& string_date)
	{

		int status = Str_func__get_split_ranges__substr_in_str__strstr(&string_date[0], &string_date[string_date.size() - 1], ":", sizeof(":") - 1, vector_ranges_split);

		if (status == 4)
		{
			vector_ranges_split.resize(0);

			error_ = "get_data_from_string: Str_func__get_split_ranges__substr_in_str__strstr__Ex() return 4";

			return -1;
		}
		else
		{

			/*
			std::tm является структурой, которая хранит время в разбитом на компоненты виде.Она содержит следующие поля :

			tm_year : годы с 1900 года
			tm_mon :  месяцы с января - [0, 11]
			tm_wday : дни с воскресенья - [0, 6]
			tm_yday : дни с 1 января - [0, 365]
			tm_mday : день месяца - [1, 31]

			tm_hour : часы после полуночи - [0, 23]
			tm_min : минуты после часа - [0, 59]
			tm_sec: секунды после минуты - [0, 60], учитывая возможность високосной секунды. *tm_sec вообще 0-59. Дополнительный диапазон предназначен для учета дополнительных секунд в определенных системах.

			tm_isdst : флаг перехода на летнее время; положительное значение означает, что летнее время действует; нулевое значение означает, что летнее время не действует; отрицательное значение означает, что информация не доступна.
			Обратите внимание, что некоторые поля имеют необычные диапазоны значений.Например, поле tm_mon имеет диапазон[0, 11], а не[1, 12], как можно было бы ожидать.Аналогично, поле tm_year содержит количество лет с 1900 года, а не абсолютный год.
			*/




			tm_.tm_year = atoi(adapter_class_.get_Cstring(vector_ranges_split[0].char_beg_p, vector_ranges_split[0].length_byte)) - 1900;  //Поле "tm_year" структуры std::tm - должно представляет собой число кол-ва лет прошедщих с 1900 года по настоящий год.
			adapter_class_.bring_back();

			tm_.tm_mon = atoi(adapter_class_.get_Cstring(vector_ranges_split[1].char_beg_p, vector_ranges_split[1].length_byte)) - 1;     //Минус один
			adapter_class_.bring_back();

			tm_.tm_mday = atoi(adapter_class_.get_Cstring(vector_ranges_split[2].char_beg_p, vector_ranges_split[2].length_byte));        //Без изменений
			adapter_class_.bring_back();

			tm_.tm_hour = atoi(adapter_class_.get_Cstring(vector_ranges_split[3].char_beg_p, vector_ranges_split[3].length_byte));        //Без изменений
			adapter_class_.bring_back();

			tm_.tm_min = atoi(adapter_class_.get_Cstring(vector_ranges_split[4].char_beg_p, vector_ranges_split[4].length_byte));         //Без изменений
			adapter_class_.bring_back();

			tm_.tm_sec = atoi(adapter_class_.get_Cstring(vector_ranges_split[5].char_beg_p, vector_ranges_split[5].length_byte));         //Без изменений
			adapter_class_.bring_back();



			vector_ranges_split.resize(0);

			return 0;
		}

	}

	//-----------------------------------------------------------------------------------get_data_from_string:Конец---------------------------------------------------------------------------------------------------





	//-----------------------------------------------------------------------------------get_cast_time_struct:Начало---------------------------------------------------------------------------------------------------

	void get_cast_time_struct(date_time__struct& date_time__struct_ref)
	{

		/*
		std::tm является структурой, которая хранит время в разбитом на компоненты виде.Она содержит следующие поля :

		tm_year : годы с 1900 года
		tm_mon :  месяцы с января - [0, 11]
		tm_wday : дни с воскресенья - [0, 6]
		tm_yday : дни с 1 января - [0, 365]
		tm_mday : день месяца - [1, 31]

		tm_hour : часы после полуночи - [0, 23]
		tm_min : минуты после часа - [0, 59]
		tm_sec: секунды после минуты - [0, 60], учитывая возможность високосной секунды. *tm_sec вообще 0-59. Дополнительный диапазон предназначен для учета дополнительных секунд в определенных системах.

		tm_isdst : флаг перехода на летнее время; положительное значение означает, что летнее время действует; нулевое значение означает, что летнее время не действует; отрицательное значение означает, что информация не доступна.
		Обратите внимание, что некоторые поля имеют необычные диапазоны значений.Например, поле tm_mon имеет диапазон[0, 11], а не[1, 12], как можно было бы ожидать.Аналогично, поле tm_year содержит количество лет с 1900 года, а не абсолютный год.
		*/


		tm_.tm_year = date_time__struct_ref.year - 1900;  //Поле "tm_year" структуры std::tm - должно представляет собой число кол-ва лет прошедщих с 1900 года по настоящий год.

		tm_.tm_mon = date_time__struct_ref.month - 1;     //Минус один

		tm_.tm_mday = date_time__struct_ref.day;          //Без изменений

		tm_.tm_hour = date_time__struct_ref.hour;         //Без изменений

		tm_.tm_min = date_time__struct_ref.min;           //Без изменений

		tm_.tm_sec = date_time__struct_ref.sec;           //Без изменений

	}

	//-----------------------------------------------------------------------------------get_cast_time_struct:Конец---------------------------------------------------------------------------------------------------




};





