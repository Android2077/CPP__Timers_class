#include <iostream>
#include <string>
#include <vector>
#include <chrono> 
#include <functional>


#include "timer_manual__class.h"
#include "timer_manual_deque__class.h"
#include "timer_auto_task__class.h"
#include "timer_clock_auto_task__class.h"




int main()
{




	//--------------------------------------------------------------------------------------------ОГЛАВЛЕНИЕ:Начало------------------------------------------------------------------------------------

	//Требуется С++11.

	//1-timer_manual__class:            "ручной" таймер: установка таймера на старт, установка паузы, ручная проверка сколько прошло времени с момента старта.
	//2-timer_manual_deque__class       "ручной" таймер с очередью в одном потоке.
	//3-timer_auto_task__class:         "автоматический" таймер: добавление таймера и функции, которая должна вызыватся после срабатывания таймера, после чего таймер удаляется.
	//4-timer_clock_auto_task__class:   "автоматический" таймер cрабатываия по конкретным часам ОС: добавление таймера и функции, которая должна вызыватся после срабатывания таймера, после чего таймер удаляется.

	//--------------------------------------------------------------------------------------------ОГЛАВЛЕНИЕ:Конец------------------------------------------------------------------------------------







	//----------------------------------------------------------------------------------------1-timer_manual__class:Начало----------------------------------------------------------------------------------
	/*
	//Шаблонынй Класс таймера, в качестве шаблона принимает:
	//- std::chrono::hours
	//- std::chrono::minutes
	//- std::chrono::seconds
	//- std::chrono::milliseconds
	//- std::chrono::microseconds
	//- std::chrono::nanoseconds


	 timer_manual__class<std::chrono::milliseconds> timer_manual__class_;                //Обьявляем класс.

	//Методы:
	
	//- start
	//- pause
	//- resume
	//- get__time
	//- get__total_pause_time



	

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^A:timer_start:начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	//Запускает таймер.

	timer_manual__class_.start();

	std::this_thread::sleep_for(std::chrono::milliseconds(3000));      //Небольшую задержку сделаем для демонстрации

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^A:timer_start:конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^B:pause:начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	//Устанавливает паузу. После вызова pause() - таймер "останавливается" и счет времени не ведется.

	timer_manual__class_.pause();       


	std::this_thread::sleep_for(std::chrono::milliseconds(5000));     //Небольшую задержку сделаем для демонстрации

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^B:pause:конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^






	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C:resume:начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	//Снимает паузу и счет времени опять продолжается.

	timer_manual__class_.resume();

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C:resume:конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^





	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^D:get__time:начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	//Возвращает кол-во времени в еденицах измерения в соответвии с выбранным шаблоном - с момента запуска таймера с учетом вызова "пауз", то есть возвращает чистое время таймера игнорируя время которое он был на паузе.

	 unsigned long long time_timer = timer_manual__class_.get__time();
	 std::cout <<"get__time:" << time_timer << std::endl;
	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^D:get__time:конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^







	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^E:get__total_pause_time:начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	//Возвращает суммарное кол-во времени паузы на данынй момент. C момента старта таймера.

	 unsigned long long time_pause = timer_manual__class_.get__total_pause_time();

	 std::cout << "get__total_pause_time:" << time_pause << std::endl;

	 //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^E:get__total_pause_time:конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	 
	 */
	//----------------------------------------------------------------------------------------1-timer_manual__class:Конец----------------------------------------------------------------------------------





	//----------------------------------------------------------------------------------------2-timer_manual_deque__class:Начало----------------------------------------------------------------------------------

	//Шаблонынй Класс таймера, в качестве шаблона принимает:
	//- std::chrono::hours
	//- std::chrono::minutes
	//- std::chrono::seconds
	//- std::chrono::milliseconds
	//- std::chrono::microseconds
	//- std::chrono::nanoseconds

    //Данный таймер не создает никаких дополнитеьлных потоков и работает в потоке из которого вызываются его методы:
    //-С помощью метода "add_timer" добавляется сам таймер и задача, которая должна выполнится. Добавлять можно неограниченное кол-во таймеров.
    //-Проверка таймера/таймеров - происходит вызовом метода "check__timer" - вызов данного метода проверяет добавленные на момент вызова таймеры и если время каких то таймеров подошло для исполнения или таймер просрочен - то выполняется соотвествующая задача, после чего таймер удаляется.


     timer_manual_deque__class<std::chrono::milliseconds>timer_manual_deque__class_;                //Обьявляем класс.

	 
	//Методы:
	
	//- add_timer
	//- check__timer



	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^A:add_timer:начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	
	//Устанавливает время таймера и функциональный обьект, который вызовется после проверки таймера, есл время таймера истекло.

	 int time1 = 2000;          //Время в еденицах измерения зависимости от выбранного шаблона класса по истечению которого, после проверки - вызовется функциональный обьект.
	 int time2 = 5000;          //Время в еденицах измерения зависимости от выбранного шаблона класса по истечению которого, после проверки - вызовется функциональный обьект.


	 std::function<void()>f_object_1 = []() { std::cout << "2000" << std::endl; };
	 std::function<void()>f_object_2 = []() { std::cout << "5000" << std::endl; };


	 timer_manual_deque__class_.add_timer(time1, f_object_1);     //Добавляем
	 timer_manual_deque__class_.add_timer(time2, f_object_2);

	 std::this_thread::sleep_for(std::chrono::milliseconds(7000));     //Небольшую задержку сделаем для демонстрации

	 //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^A:add_timer:конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^




	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^B:check__timer:начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	//Проверяем статус всех доабвленных на этот момент таймеров, все таймеры у котороых время таймера уже истекло вызовут ранее переданные функциональые обьекты.

	 timer_manual_deque__class_.check__timer();

	 //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^B:check__timer:конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


	//----------------------------------------------------------------------------------------2-timer_manual_deque__class:Конец----------------------------------------------------------------------------------








	 //----------------------------------------------------------------------------------------3-timer_auto_task__class:Начало----------------------------------------------------------------------------------
   /*
	//Шаблонынй Класс авто-таймера с исполняемой функцией, потоко-безопасный, может вызываться из любого потока, в качестве шаблона принимает:
	//- std::chrono::hours
	//- std::chrono::minutes
	//- std::chrono::seconds
	//- std::chrono::milliseconds
	//- std::chrono::microseconds
	//- std::chrono::nanoseconds


   
   //Данный таймер работает минимум в двух потоках: все потоки создаются внутри таймера.
   //-С помощью метода "add_timer" добавляется сам таймер и задача, которая должна выполнится. Добавлять можно неограниченное кол-во таймеров.
   //-Первый поток создается автоматически и в нем выполняется проверка и отслеживаение времени таймера. Если время таймера подошло, то соответсвующая задача помещается в очередь на исполнение. Очередь задач обробатывают другие потоки, число которых устанвливается методом "set_number_threads".
   //-Поэтому нужно понмить, что любая задача соответвующая таймеру - будет выполнена в другом потоке, не в потоке создания обьекта класса "timer_auto_task__class". После выполнения задачи - таймер удаляется.


     timer_auto_task__class<std::chrono::milliseconds> timer_auto_task__class_;        //Обьявим класс.

	//Методы:

	//- set_number_threads
	//- add_timer



	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^A-set_number_threads:Начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	 int numm_threads = 2;         //Кол-во потоков, которые будут обробатывать очередь "задач" функций, которые нужно выполнить по истечению каждого доабвленного таймера. ТО ЕСТЬ - я добавил таймер вместе с функцией, которая должна выполнится, после истичения таймера - переданная функция помещается в очередь задач и и эта очередь задач обробатывается указанным кол-во потоков, то есть какой то из потоков забирает задачу и выполняет ее, это сделано, чтобы поток в котором работает таймер - не блокировался выполнением Пользовтаельской функции.

	 timer_auto_task__class_.set_number_threads(numm_threads);

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^A-set_number_threads:Начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^







	 //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^B-add_timer:Начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	 
	 //Добавляет новый таймер на срабатывание.

	 int time = 3000;          //Время в еденицах измерения зависимости от выбранного шаблона класса по истечению которого вызовется функциональный обьект.

	 std::function<void()>f_object = [time] () { std::cout << "Callback__CALL:" << time << std::endl; };    //Функциональный обьект, который вызовется при срабатывании таймера.

	 timer_auto_task__class_.add_timer(time, f_object);      //Добовляем таймер: time - время с момента вызова данного метода по истечению которого вызовется "f_object".



	 time = 4000;
	 timer_auto_task__class_.add_timer(time, [time]() { std::cout << "Callback__CALL:" << time << std::endl; });      //Добовляем таймер: time - время с момента вызова данного метода по истечению которого вызовется "f_object".
	 
	 //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^B-add_timer:Конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	 
	 
	 */
     //----------------------------------------------------------------------------------------3-timer_auto_task__class:Конец----------------------------------------------------------------------------------













	 //--------------------------------------------------------------------------------------4-timer_clock_auto_task__class:Начало----------------------------------------------------------------------------------


    //Авто-часовой таймер с исполняемой функцией.

   //Данный таймер работает минимум в двух потоках: все потоки создаются внутри таймера.
   //-С помощью метода "add_timer" добавляется сам таймер и задача, которая должна выполнится. Добавлять можно неограниченное кол-во таймеров.
   //-Первый поток создается автоматически и в нем выполняется проверка и отслеживаение времени таймера. Если время таймера подошло, то соответсвующая задача помещается в очередь на исполнение. Очередь задач обробатывают другие потоки, число которых устанвливается методом "set_number_threads".
   //-Поэтому нужно понмить, что любая задача соответвующая таймеру - будет выполнена в другом потоке, не в потоке создания обьекта класса "timer_auto_task__class". После выполнения задачи - таймер удаляется.




      timer_clock_auto_task__class timer_clock_auto_task__class_;      //Обьявим класс.

	//Методы:

	//- set_number_threads
	//- add_timer_string
	//- add_timer_struct
	  

	  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^A-set_number_threads:Начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	  int numm_threads = 2;         //Кол-во потоков, которые будут обробатывать очередь "задач" функций, которые нужно выполнить по истечению каждого доабвленного таймера. ТО ЕСТЬ - я добавил таймер вместе с функцией, которая должна выполнится, после истичения таймера - переданная функция помещается в очередь задач и и эта очередь задач обробатывается указанным кол-во потоков, то есть какой то из потоков забирает задачу и выполняет ее, это сделано, чтобы поток в котором работает таймер - не блокировался выполнением Пользовтаельской функции.

	  timer_clock_auto_task__class_.set_number_threads(numm_threads);

	  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^A-set_number_threads:Начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^





	   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^B-add_timer_string:Начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	     std::string string_time_alarm = "2023:07:17:12:37:10";       //Дата и время срабатывания таймера, указывается ТОЛЬКО СТРОГО в данном формате: Год:месяц:день:час:минута:секунда

		 std::function<void()>f_object = [string_time_alarm]() { std::cout << "Callback__CALL:" << string_time_alarm << std::endl; };  //Функциональный обьект, который вызовется при срабатывании таймера.


	     timer_clock_auto_task__class_.add_timer_string(string_time_alarm, f_object);                //Вызываем.
		 //НЮАНС: ЕСЛИ после того, как было установлено дата и время срабатывания таймера, Вы измените системное рвемя ОС врчную или оно изменится автоматчиески (переход на зимне-летнее время к примеру), то это изменение ни как не повлияет на срабатывание таймера в установленное время, ТАК КАК после того, как Вы добавили таймер с датой и временм - таймер срабоатывает ЧЕРЕЗ абсолютное вермя - которое является РАЗНИЦОЙ между указанными датой и временем для срабатывания таймера и текущем временмм на момент доавбления таймера.



		 string_time_alarm = "2023:07:17:12:37:15";

		 timer_clock_auto_task__class_.add_timer_string(string_time_alarm, [string_time_alarm]() { std::cout << "Callback__CALL:" << string_time_alarm << std::endl; });


	   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^B-add_timer_string:Конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	   




	   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C-add_timer_struct:Начало^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


		 timer_clock_auto_task__class::date_time__struct date_time__struct_;            //Дата и время срабатывания таймера заполняются все поля структуры: Год:месяц:день:час:минута:секунда	 
		 date_time__struct_.year = 2025;                  //2025 год
		 date_time__struct_.month = 1;                    //январь
		 date_time__struct_.day = 12;                     //12 января
		 date_time__struct_.hour = 18;                    //18 часа
		 date_time__struct_.min = 12;                     //11 минут 
		 date_time__struct_.sec = 03;                     //3 секунда.


		 std::function<void()>f_object_ = [date_time__struct_]() { std::cout << "Callback__CALL:" << date_time__struct_.year <<":" << date_time__struct_.month <<":" << date_time__struct_.day  <<":" << date_time__struct_.hour  <<":" << date_time__struct_.min <<":" << date_time__struct_.sec << std::endl; };  //Функциональный обьект, который вызовется при срабатывании таймера.


	     timer_clock_auto_task__class_.add_timer_struct(date_time__struct_, f_object_);      //Вызываем.
		 //НЮАНС: ЕСЛИ после того, как было установлено дата и время срабатывания таймера, Вы измените системное рвемя ОС врчную или оно изменится автоматчиески (переход на зимне-летнее время к примеру), то это изменение ни как не повлияет на срабатывание таймера в установленное время, ТАК КАК после того, как Вы добавили таймер с датой и временм - таймер срабоатывает ЧЕРЕЗ абсолютное вермя - которое является РАЗНИЦОЙ между указанными датой и временем для срабатывания таймера и текущем временмм на момент доавбления таймера.




	   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C-add_timer_struct:Конец^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


	   


	 //--------------------------------------------------------------------------------------4-timer_clock_auto_task__class:Конец----------------------------------------------------------------------------------




		std::this_thread::sleep_for(std::chrono::milliseconds(500000));     //Небольшую задержку сделаем для демонстрации


}



